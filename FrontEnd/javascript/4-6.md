<h2> 04장 변수 </h2>

<h4>4.1 변수란 무엇인가</h4>

 - 컴퓨터는 cpu를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.
 - 각 변수는 메모리상 임의의 위치에 2진수로 저장된다.
 - js는 개발자의 직접적인 메모리 접근을 허용하지 않는다 (변수를 통해서만 가능)
 - 변수는 컴파일러 혹은 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다.
 - 변수 참조는 js 엔진이 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 값을 반환한다.
<h4>4.2 식별자</h4>

 - 변수명 ⊆ 식별자
 - 식별자는 어떤 값을 구분할 수 있는 고유한 이름. 메모리 주소를 기억하고 있다.
 - 변수 선언을 함으로써 js엔진에 식별자의 존재를 알린다.

<h4>4.3 변수 선언</h4>

 - 선언 
	 1. 값 저장을 위한 메모리 공간 확보
	 2. 변수 이름 ~ 메모리 공간 연결
- var 키워드 단점 : 함수 레벨 스코프를 지원한다. 
- 변수 선언 후 값을 할당하지 않으면 undefined로 초괴화된다.
- 모든 식별자는 실행 컨텍스트에 등록된다.
- 선언하지 않는 식별자 참조 시 ReferenceError 발생

<h4>4.4 변수 선언의 실행 시점과 변수 호이스팅</h4>

* 소스코드 평가 과정 (ex. 선언문 실행) -> 소스 코드 순차적 실행(run time)
* js 엔진은 변수가 어디에 있든 다른 코드보다 먼저 실행
* 변수 호이스팅 : 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 것

<h4>4.6 값의 재할당</h4>

* 값의 재할당은 새로운 메모리 공간을 확보해서 이루어 진다.
* 원래 있던 차지되던 메모리 주소 -> 가비지콜렉팅
* 프로그래밍 언어 (메모리 관리 방식에 따른 분류)
	1. 언매니지드 : 메모리 제어를 개발자가 가능
	2. 매니지드 : 메모리 관리를 언어가 담당. 개발자가 메모리 제어 x

<h4>4.7 식별자 네이밍 규칙</h4>

1. camel case : 변수, 함수
2. pascal case : 생성자 함수, 클래스

<h2> 05장 표현식과 문 </h2>
<h4>5.1 값</h4>

* 값 : 표현식이 평가되어 생성된 결과

<h4>5.2 리터럴</h4>

* 리터럴 : 사람이 이해할 수 있는 문자 or 약속된 기호로 값을 생성하는 표기법
* js 엔진은 런타임에 리터럴을 평가해 값을 생성

<h4>5.3 표현식</h4>

* '표현식'과 '값'은 동치
* 값이 위치할 수 있는 자리 -> 표현식이 대치 가능

<h4>5.4 문</h4>

* 문 : 프로그램을 구성하는 최소 실행 단위 & 컴퓨터에 내리는 명령

<h4>5.5 세미콜론</h4>

* js engine은 state의 끝에 세미콜론을 자동으로 붙여준다.

<h4>5.6 표현식인 문과 표현식이 아닌 문</h4>

* 표현식 ⊆ 문
* 표현식 : 문 중에 값으로 평가 가능한 문
